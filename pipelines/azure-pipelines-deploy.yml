trigger: none

pool:
  vmImage: 'ubuntu-latest'

parameters:
  - name: tag
    displayName: Ingresar Tag
    type: string
    default: ''
    values: []
  - name: ambiente
    displayName: Ingresar Ambiente
    type: string
    default: 'dev'
    values:
      - dev
      - qa
      - prd

variables:
  REPOSITORY_NAME: "gen-useast2-ecr-portal-bff-01"
  AWS_DEFAULT_REGION: "us-east-2"
  ACCOUNT_ID: 00000000000
  ECS_CLUSTER: "${{ parameters.ambiente }}-useast2-ecs-portal-01"
  ECS_SERVICE: "${{ parameters.ambiente }}-useast2-ecsservice-bff-portal-01"
  TASK_DEFINITION: "${{ parameters.ambiente }}-useast2-ecstask-bff-portal-01"
  SELECTED_TAG: ''

stages:
  - stage: Deploy
    displayName: Deploy Task Definition y ECS
    jobs:
      - job: Deploy
        displayName: Deploy Task Definition y ECS
        steps:
          # 1. Validar y procesar el parámetro de entrada
          - script: |
              echo "Tag ingresado por el usuario:" ${{ parameters.tag }}
              if [ -z "${{ parameters.tag }}" ]; then
                echo "Error: No se proporcionó un tag válido."
                exit 1
              fi
              # Guardar el valor como variable de pipeline
              echo "##vso[task.setvariable variable=SELECTED_TAG]${{ parameters.tag }}"
              # echo "Tag seleccionado: ${{ parameters.tag }}"
            displayName: "Tag ingresado por el usuario"

          - task: AWSShellScript@1
            displayName: "Lista de Tags disponibles"
            inputs:
              awsCredentials: "AWS - terraform - Generic-Containers"
              regionName: us-east-2
              scriptType: inline
              inlineScript: |
                aws ecr list-images --repository-name $REPOSITORY_NAME --query "imageIds[].imageTag" --output text | tr '\t' '\n' | sort -r > tags.txt
                echo "Tags disponibles:"
                cat tags.txt

          - script: |
              TAG_FILE=tags.txt
              INPUT_TAG=${{ parameters.tag }}

              if grep -Fxq $INPUT_TAG $TAG_FILE; then
                echo "El tag $INPUT_TAG es válido."
              else
                echo "Error: El tag $INPUT_TAG no existe en el repositorio AWS ECR."
                exit 1
              fi
            displayName: "Validar tag seleccionado"

          - script: |
              echo "Desplegando con el tag:" $(SELECTED_TAG)
            displayName: "Confirmacion del Tag"

          - task: AWSShellScript@1
            displayName: "Deploy Task Definition y ECS"
            inputs:
              awsCredentials: "AWS - terraform - Generic-Containers"
              regionName: us-east-2
              scriptType: inline
              inlineScript: |
                echo "UPDATE TASK DEFINITION WITH NEW IMAGE"
                # Obtener la definición de la tarea actual
                TASK_DEFINITION_JSON=$(aws ecs describe-task-definition --task-definition "$TASK_DEFINITION")

                # Extraer container definitions y family
                CONTAINER_DEFINITIONS=$(echo "$TASK_DEFINITION_JSON" | jq '.taskDefinition.containerDefinitions')
                FAMILY=$(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.family')

                # Actualizar la imagen del contenedor en la task definition (asegurarse de obtener un array válido)
                UPDATED_CONTAINER_DEFINITIONS=$(echo "$CONTAINER_DEFINITIONS" | jq --arg IMAGE "$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$REPOSITORY_NAME:$SELECTED_TAG" 'map(if .name | startswith("") then .image = $IMAGE else . end)')

                # Registrar la nueva task definition
                NEW_TASK_DEFINITION=$(aws ecs register-task-definition \
                  --family "$FAMILY" \
                  --container-definitions "$UPDATED_CONTAINER_DEFINITIONS" \
                  --execution-role-arn $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.executionRoleArn') \
                  --task-role-arn $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.taskRoleArn') \
                  --network-mode $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.networkMode') \
                  --requires-compatibilities $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.requiresCompatibilities[]') \
                  --cpu $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.cpu') \
                  --memory $(echo "$TASK_DEFINITION_JSON" | jq -r '.taskDefinition.memory'))

                if [[ $? -ne 0 ]]; then
                  echo "ERROR: Falló la creación de la nueva Task Definition"
                  exit 1
                fi

                # Obtener la nueva revision de la task definition
                NEW_TASK_REVISION=$(echo "$NEW_TASK_DEFINITION" | jq -r '.taskDefinition.taskDefinitionArn')

                # Actualizar el servicio con la nueva task definition revision
                echo "UPDATE SERVICE WITH NEW TASK DEFINITION"
                RESULT_UPDATE_SERVICE=$(aws ecs update-service \
                  --cluster "$ECS_CLUSTER" \
                  --service "$ECS_SERVICE" \
                  --task-definition "$NEW_TASK_REVISION" \
                  --force-new-deployment)

                if [[ $? -ne 0 ]]; then
                  echo "ERROR: Falló la actualización del servicio ECS"
                  exit 1
                fi
